Index: scripts/scenes/main_menu.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nfrom PIL import Image\r\nfrom settings import SCREEN_WIDTH, SCREEN_HEIGHT, WHITE, DEFAULT_FONT\r\nimport time\r\nimport json\r\nimport os\r\nfrom scripts.locations.cabin import start_game_in_cabin\r\nfrom settings import DISPLAYSURF\r\n\r\n\r\nclass MainMenu:\r\n    def __init__(self):\r\n        self.settings = Settings(self)\r\n        self.font = pygame.font.Font(DEFAULT_FONT, 60)\r\n        self.title_text = self.settings.get_text('title')\r\n        self.start_text = self.settings.get_text('press_enter')\r\n        self.fullscreen = False\r\n        self.language = 'ru'\r\n        self.button_texts = ['Продолжить', 'Начать игру', 'Настройки', 'Выход']\r\n        self.buttons = [self.font.render(text, True, (0, 0, 255)) for text in self.button_texts]\r\n\r\n        self.button_width = max(button.get_width() for button in self.buttons)\r\n        self.button_height = self.buttons[0].get_height()\r\n\r\n        self.x_offset = 0\r\n        self.y_offset = -110\r\n        self.x_show=0\r\n        self.y_show=-360\r\n        self.background = pygame.image.load(\"assets/images/map.png\")\r\n        self.background = pygame.transform.scale(self.background, (self.button_width + 30, self.button_height + 10))\r\n        self.frames = self.load_gif(\"assets/videos/sea.gif\")\r\n        self.current_frame = 0\r\n        self.frame_count = len(self.frames)\r\n        self.frame_delay = 0.1\r\n        self.last_update = pygame.time.get_ticks()\r\n\r\n        self.alpha = 255\r\n        self.fade_duration = 10\r\n        self.fade_start_time = pygame.time.get_ticks()\r\n\r\n        self.cursor = pygame.image.load(\"assets/images/cursor.png\")\r\n        self.cursor = pygame.transform.scale(self.cursor, (14, 20))\r\n        self.cursor_rect = self.cursor.get_rect()\r\n\r\n        pygame.mouse.set_visible(False)\r\n\r\n        self.clock = pygame.time.Clock()\r\n\r\n        pygame.mixer.init()\r\n        self.menu_music_path = \"audio/music/menu_theme.mp3\"\r\n        self.music_playing = False\r\n        self.music_delay = 100\r\n        self.show_main_menu = False\r\n        self.show_options_menu = False\r\n        self.music_start_time = None\r\n        self.selected_button = 0\r\n        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n        self.last_text_update = pygame.time.get_ticks()\r\n        self.text_speed = 60\r\n        self.text_displayed = \"\"\r\n\r\n        self.last_back_click_time = 0\r\n        self.back_click_delay = 200\r\n\r\n        self.last_click_time = pygame.time.get_ticks()\r\n        self.click_delay = 200\r\n\r\n        self.game_started = False\r\n\r\n        self.settings = Settings(self)\r\n        self.update_button_texts()\r\n\r\n    def load_gif(self, gif_path):\r\n        gif = Image.open(gif_path)\r\n        frames = []\r\n        for frame in range(gif.n_frames):\r\n            gif.seek(frame)\r\n            frame_image = pygame.image.fromstring(gif.convert('RGB').tobytes(), gif.size, 'RGB')\r\n            frames.append(frame_image)\r\n        return frames\r\n\r\n    def play_menu_music(self):\r\n        current_time = pygame.time.get_ticks()\r\n        if self.music_start_time is None:\r\n            self.music_start_time = current_time\r\n\r\n        if current_time - self.music_start_time >= self.music_delay:\r\n            if not self.music_playing:\r\n                pygame.mixer.music.load(self.menu_music_path)\r\n                pygame.mixer.music.play(-1)\r\n                self.music_playing = True\r\n\r\n    def stop_menu_music(self):\r\n        if self.music_playing:\r\n            pygame.mixer.music.stop()\r\n            self.music_playing = False\r\n\r\n    def update_button_texts(self):\r\n        self.button_texts = [\r\n            self.settings.get_text('continue'),\r\n            self.settings.get_text('start_game'),\r\n            self.settings.get_text('settings'),\r\n            self.settings.get_text('exit')\r\n        ]\r\n        self.buttons = [self.font.render(text, True, (0, 0, 255)) for text in self.button_texts]\r\n\r\n    def handle_mouse_click(self, mouse_x, mouse_y):\r\n        current_time = pygame.time.get_ticks()\r\n\r\n        if current_time - self.last_click_time < 500:\r\n            return\r\n\r\n        if not self.game_started:\r\n            return\r\n\r\n        if current_time - self.last_click_time < 200:\r\n            return\r\n\r\n        if self.show_options_menu:\r\n            return\r\n\r\n        else:\r\n            button_coords = []\r\n            button_y_offset = 40\r\n\r\n            for i, button_text in enumerate(self.button_texts):\r\n                button_rect = pygame.Rect(\r\n                    SCREEN_WIDTH // 2 - self.background.get_width() // 2 + self.x_offset,\r\n                    SCREEN_HEIGHT // 2 + i * (self.button_height + 20) + button_y_offset + self.y_offset,\r\n                    self.background.get_width(),\r\n                    self.background.get_height()\r\n                )\r\n\r\n                button_coords.append((button_rect, button_text))\r\n\r\n                pygame.draw.rect(self.screen, (255, 0, 0), button_rect, 2)\r\n\r\n            for button_rect, button_text in button_coords:\r\n                if button_rect.collidepoint(mouse_x, mouse_y) and pygame.mouse.get_pressed()[0]:\r\n                    if current_time - self.last_click_time > self.click_delay:\r\n                        self.last_click_time = current_time\r\n\r\n                        if button_text == 'Продолжить':\r\n                            pass\r\n                        elif button_text == 'Начать игру':\r\n                            self.start_game()\r\n                        elif button_text == 'Выход':\r\n                            self.quit_game()\r\n\r\n                        self.execute_action(button_text)\r\n                        return\r\n\r\n    def handle_options_menu_click(self, mouse_x, mouse_y):\r\n        current_time = pygame.time.get_ticks()\r\n\r\n        if current_time - self.last_click_time < 200:\r\n            return\r\n\r\n\r\n        option_texts = [\r\n            f\"Звук: {int(self.settings.volume * 100)}%\",\r\n            f\"Смена языка: {self.settings.language}\",\r\n            f\"Автосохранение: {'Включено' if self.settings.autosave else 'Выключено'}\",\r\n            f\"Сложность: {self.settings.difficulty}\"\r\n        ]\r\n\r\n        option_buttons = []\r\n\r\n\r\n        for i, option_text in enumerate(option_texts):\r\n            option_label = self.font.render(option_text, True, (0, 0, 255))\r\n\r\n            text_width = option_label.get_width()\r\n            text_height = option_label.get_height()\r\n\r\n\r\n            bg_width = text_width + 40\r\n            bg_height = text_height + 20\r\n\r\n\r\n            option_bg_x = SCREEN_WIDTH // 2 - bg_width // 2 + self.x_show\r\n            option_bg_y = SCREEN_HEIGHT // 3 + i * (bg_height + 30) + 400 + self.y_show\r\n\r\n\r\n            option_buttons.append((option_bg_x, option_bg_y, bg_width, bg_height, i))\r\n\r\n\r\n            pygame.draw.rect(self.screen, (255, 0, 0), (option_bg_x, option_bg_y, bg_width, bg_height),\r\n                             2)\r\n\r\n\r\n            if option_bg_x < mouse_x < option_bg_x + bg_width and option_bg_y < mouse_y < option_bg_y + bg_height:\r\n                if pygame.mouse.get_pressed()[0]:\r\n                    if current_time - self.last_click_time > self.click_delay:\r\n                        if i == 0:\r\n                            self.settings.change_volume(0.1)\r\n                        elif i == 1:\r\n                            new_language = 'en' if self.settings.language == 'ru' else 'ru'\r\n                            self.settings.change_language(new_language)\r\n                        elif i == 2:\r\n                            self.settings.toggle_autosave()\r\n                        elif i == 3:\r\n                            self.settings.change_difficulty()\r\n                        self.last_click_time = current_time\r\n\r\n\r\n        back_label = self.font.render('Назад', True, (0, 0, 255))\r\n        back_text_width = back_label.get_width()\r\n        back_text_height = back_label.get_height()\r\n\r\n        back_bg_width = back_text_width + 45\r\n        back_bg_height = back_text_height + 20\r\n\r\n\r\n        back_bg_x = SCREEN_WIDTH // 2 - back_bg_width // 2 + self.x_show\r\n        back_bg_y = SCREEN_HEIGHT - back_bg_height  + self.y_show\r\n\r\n\r\n        pygame.draw.rect(self.screen, (255, 0, 0), (back_bg_x, back_bg_y, back_bg_width, back_bg_height),\r\n                         2)\r\n\r\n\r\n        if back_bg_x < mouse_x < back_bg_x + back_bg_width and back_bg_y < mouse_y < back_bg_y + back_bg_height:\r\n            if pygame.mouse.get_pressed()[0]:\r\n                if current_time - self.last_click_time > self.click_delay:\r\n                    self.show_options_menu = False\r\n                    self.last_click_time = current_time\r\n\r\n    def display(self, surface):\r\n        surface.fill((0, 0, 0))\r\n        current_frame_resized = pygame.transform.scale(self.frames[self.current_frame], (SCREEN_WIDTH, SCREEN_HEIGHT))\r\n        surface.blit(current_frame_resized, (0, 0))\r\n\r\n        current_time = pygame.time.get_ticks()\r\n        fade_elapsed = current_time - self.fade_start_time\r\n        if fade_elapsed < self.fade_duration:\r\n            self.alpha = 255 - (fade_elapsed / self.fade_duration) * 255\r\n        else:\r\n            self.alpha = 0\r\n        if not self.music_playing and not self.game_started:\r\n            self.play_menu_music()\r\n        fade_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n        fade_surface.fill((0, 0, 0))\r\n        fade_surface.set_alpha(self.alpha)\r\n        surface.blit(fade_surface, (0, 0))\r\n\r\n        if self.alpha <= 0:\r\n            if not self.game_started:\r\n                if current_time - self.last_text_update > self.text_speed:\r\n                    if len(self.text_displayed) < len(self.start_text):\r\n                        self.text_displayed += self.start_text[len(self.text_displayed)]\r\n                        self.last_text_update = current_time\r\n                surface.blit(self.font.render(self.text_displayed, True, WHITE),\r\n                             (SCREEN_WIDTH // 2 - self.font.size(self.text_displayed)[0] // 2, SCREEN_HEIGHT // 2))\r\n            else:\r\n                if not self.show_main_menu and not self.show_options_menu:\r\n                    self.show_main_menu = True\r\n\r\n                if self.show_options_menu:\r\n                    self.display_options_menu(surface)\r\n                    mouse_x, mouse_y = pygame.mouse.get_pos()\r\n                    self.handle_options_menu_click(mouse_x, mouse_y)\r\n                else:\r\n                    surface.blit(self.font.render(self.title_text, True, WHITE),\r\n                                 (SCREEN_WIDTH // 2 - self.font.size(self.title_text)[0] // 2, SCREEN_HEIGHT // 3))\r\n\r\n                    y_offset = 70\r\n\r\n                    for i, button in enumerate(self.buttons):\r\n                        surface.blit(self.background, (SCREEN_WIDTH // 2 - self.background.get_width() // 2,\r\n                                                       SCREEN_HEIGHT // 2 + i * (self.button_height + 20) - y_offset))\r\n\r\n                    mouse_x, mouse_y = pygame.mouse.get_pos()\r\n\r\n                    for i, button in enumerate(self.buttons):\r\n                        button_rect = pygame.Rect(\r\n                            SCREEN_WIDTH // 2 - self.background.get_width() // 2,\r\n                            SCREEN_HEIGHT // 2 + i * (self.button_height + 20) - y_offset,\r\n                            self.background.get_width(),\r\n                            self.background.get_height()\r\n                        )\r\n\r\n                        button_color = (255, 255, 255) if button_rect.collidepoint(mouse_x, mouse_y) else (0, 0, 255)\r\n                        button_text = self.font.render(self.button_texts[i], True, button_color)\r\n                        surface.blit(button_text, (SCREEN_WIDTH // 2 - button_text.get_width() // 2,\r\n                                                   SCREEN_HEIGHT // 2 + i * (self.button_height + 20) - y_offset))\r\n\r\n        mouse_x, mouse_y = pygame.mouse.get_pos()\r\n        self.cursor_rect.topleft = (mouse_x, mouse_y)\r\n        surface.blit(self.cursor, self.cursor_rect)\r\n\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                if not self.show_options_menu:\r\n                    self.quit_game()\r\n\r\n            if event.type == pygame.KEYDOWN:\r\n                if not self.game_started:\r\n                    if event.key == pygame.K_RETURN:\r\n                        self.game_started = True\r\n                        self.show_main_menu = True\r\n                    return\r\n\r\n                if self.show_main_menu:\r\n                    if event.key == pygame.K_DOWN:\r\n                        self.selected_button = (self.selected_button + 1) % len(self.buttons)\r\n                    elif event.key == pygame.K_UP:\r\n                        self.selected_button = (self.selected_button - 1) % len(self.buttons)\r\n\r\n                    if event.key == pygame.K_RETURN:\r\n                        self.execute_action(self.button_texts[self.selected_button])\r\n                    elif event.key == pygame.K_ESCAPE and self.show_options_menu:\r\n                        self.show_options_menu = False\r\n\r\n        if current_time - self.last_update > self.frame_delay * 1000:\r\n            self.last_update = current_time\r\n            self.current_frame = (self.current_frame + 1) % self.frame_count\r\n\r\n        self.clock.tick(120)\r\n\r\n        self.handle_mouse_click(mouse_x, mouse_y)\r\n\r\n    def execute_action(self, button_text=None):\r\n        if button_text is None:\r\n            button_text = self.button_texts[self.selected_button]\r\n\r\n        if button_text == self.button_texts[0]:\r\n            pass\r\n        elif button_text == self.button_texts[1]:\r\n            self.start_game()\r\n        elif button_text == self.button_texts[2]:\r\n            self.show_options_menu = True\r\n        elif button_text == self.button_texts[3]:\r\n            self.quit_game()\r\n\r\n    def update_button_texts(self):\r\n        self.button_texts = [\r\n            self.settings.get_text('continue'),\r\n            self.settings.get_text('start_game'),\r\n            self.settings.get_text('settings'),\r\n            self.settings.get_text('exit')\r\n        ]\r\n        self.buttons = [self.font.render(text, True, (0, 0, 255)) for text in self.button_texts]\r\n\r\n    def quit_game(self):\r\n        pygame.quit()\r\n        quit()\r\n\r\n    def start_game(self):\r\n        self.stop_menu_music()\r\n        start_game_in_cabin(DISPLAYSURF)\r\n\r\n    def display_options_menu(self, surface):\r\n        option_texts = [\r\n            self.settings.get_text('volume', volume=int(self.settings.volume * 100)),\r\n            self.settings.get_text('change_language') + f\": {self.settings.language.upper()}\",\r\n            self.settings.get_text('autosave', status='Включено' if self.settings.autosave else 'Выключено'),\r\n            self.settings.get_text('difficulty', difficulty=self.settings.difficulty)\r\n        ]\r\n\r\n        mouse_x, mouse_y = pygame.mouse.get_pos()\r\n        option_buttons = []\r\n\r\n        for i, option_text in enumerate(option_texts):\r\n            option_label = self.font.render(option_text, True, (0, 0, 255))\r\n            text_width = option_label.get_width()\r\n            text_height = option_label.get_height()\r\n            bg_width = text_width + 40\r\n            bg_height = text_height + 20\r\n\r\n            option_bg_x = SCREEN_WIDTH // 2 - bg_width // 2\r\n            option_bg_y = SCREEN_HEIGHT // 3 + i * (bg_height + 30) + 30\r\n\r\n            option_buttons.append((option_bg_x, option_bg_y, bg_width, bg_height))\r\n            button_bg = pygame.transform.scale(self.background, (bg_width, bg_height))\r\n            surface.blit(button_bg, (option_bg_x, option_bg_y))\r\n\r\n            if option_bg_x < mouse_x < option_bg_x + bg_width and option_bg_y < mouse_y < option_bg_y + bg_height:\r\n                option_label = self.font.render(option_text, True, (255, 255, 255))\r\n            surface.blit(option_label, (option_bg_x + 10, option_bg_y + 10))\r\n\r\n        back_label = self.font.render(self.settings.get_text('back'), True, (0, 0, 255))\r\n        back_text_width = back_label.get_width()\r\n        back_text_height = back_label.get_height()\r\n\r\n        back_bg_width = back_text_width + 45\r\n        back_bg_height = back_text_height + 20\r\n        back_bg_x = SCREEN_WIDTH // 2 - back_bg_width // 2\r\n        back_bg_y = SCREEN_HEIGHT - back_bg_height - 360\r\n\r\n        button_bg = pygame.transform.scale(self.background, (back_bg_width, back_bg_height))\r\n        surface.blit(button_bg, (back_bg_x, back_bg_y))\r\n\r\n        surface.blit(back_label, (back_bg_x + 10, back_bg_y + 10))\r\n\r\n        if back_bg_x < mouse_x < back_bg_x + back_bg_width and back_bg_y < mouse_y < back_bg_y + back_bg_height:\r\n            back_label = self.font.render(self.settings.get_text('back'), True, (255, 255, 255))\r\n            surface.blit(back_label, (back_bg_x + 10, back_bg_y + 10))\r\n\r\n    def set_language(self, language):\r\n        self.settings.language = language\r\n\r\n    def update_title_text(self):\r\n        self.title_text = self.settings.get_text('title')\r\n\r\n\r\nclass Settings:\r\n    def __init__(self, main_menu_instance):\r\n        self.volume = 1.0\r\n        self.resolution = (SCREEN_WIDTH, SCREEN_HEIGHT)\r\n        self.fullscreen = False\r\n        self.language = 'ru'\r\n        self.autosave = True\r\n        self.difficulty = 'Легко'\r\n\r\n        self.settings_file = 'config/game_settings.json'\r\n        self.text_file = f'localization/{self.language}.json'\r\n        self.main_menu = main_menu_instance\r\n\r\n        self.load_settings_from_json()\r\n        self.load_texts_from_json()\r\n\r\n    def load_texts_from_json(self):\r\n        if os.path.exists(self.text_file):\r\n            with open(self.text_file, mode='r', encoding='utf-8') as file:\r\n                self.text_data = json.load(file)\r\n        else:\r\n            raise FileNotFoundError(f\"Текстовый файл для языка {self.language} не найден.\")\r\n\r\n    def get_text(self, key, **kwargs):\r\n\r\n        text = self.text_data.get(key, \"\")\r\n\r\n        if 'status' in kwargs:\r\n            if self.language == 'ru':\r\n                status = 'Включено' if self.autosave else 'Выключено'\r\n            else:\r\n                status = 'Enabled' if self.autosave else 'Disabled'\r\n            kwargs['status'] = status\r\n\r\n        if 'difficulty' in kwargs:\r\n            if self.language == 'ru':\r\n                difficulty = self.difficulty\r\n            else:\r\n                difficulty_mapping = {\r\n                    'Легко': 'Easy',\r\n                    'Средне': 'Medium',\r\n                    'Трудно': 'Hard'\r\n                }\r\n                difficulty = difficulty_mapping.get(self.difficulty, self.difficulty)\r\n            kwargs['difficulty'] = difficulty\r\n\r\n        return text.format(**kwargs)\r\n\r\n    def save_settings_to_json(self):\r\n        settings_data = {\r\n            'volume': self.volume,\r\n            'autosave': self.autosave,\r\n            'difficulty': self.difficulty,\r\n            'language': self.language\r\n        }\r\n        with open(self.settings_file, mode='w', encoding='utf-8') as file:\r\n            json.dump(settings_data, file, ensure_ascii=False, indent=4)\r\n\r\n    def load_settings_from_json(self):\r\n        if os.path.exists(self.settings_file):\r\n            with open(self.settings_file, mode='r', encoding='utf-8') as file:\r\n                settings_data = json.load(file)\r\n                self.volume = settings_data.get('volume', 1.0)\r\n                self.autosave = settings_data.get('autosave', True)\r\n                self.difficulty = settings_data.get('difficulty', 'Легко')\r\n                self.language = settings_data.get('language', 'ru')\r\n                self.text_file = f'localization/{self.language}.json'\r\n                self.load_texts_from_json()\r\n\r\n    def change_language(self, new_language):\r\n        self.language = new_language\r\n        self.text_file = f'localization/{self.language}.json'\r\n        self.load_texts_from_json()\r\n        self.save_settings_to_json()\r\n        self.main_menu.update_button_texts()\r\n        self.main_menu.update_title_text()\r\n        self.main_menu.show_main_menu = True\r\n\r\n    def update_main_menu_button_texts(self):\r\n        if hasattr(self, 'main_menu'):\r\n            self.main_menu.update_button_texts()\r\n\r\n    def change_volume(self, amount=0.1):\r\n        self.volume = max(0.0, min(1.0, self.volume + amount))\r\n        pygame.mixer.music.set_volume(self.volume)\r\n        self.save_settings_to_json()\r\n\r\n    def toggle_fullscreen(self):\r\n        self.fullscreen = not self.fullscreen\r\n        pygame.display.set_mode(self.resolution, pygame.FULLSCREEN if self.fullscreen else 0)\r\n        self.save_settings_to_json()\r\n\r\n    def toggle_autosave(self):\r\n        self.autosave = not self.autosave\r\n        self.save_settings_to_json()\r\n\r\n    def change_difficulty(self):\r\n        difficulties = ['Легко', 'Средне', 'Трудно']\r\n        current_index = difficulties.index(self.difficulty)\r\n        next_index = (current_index + 1) % len(difficulties)\r\n        self.difficulty = difficulties[next_index]\r\n        self.save_settings_to_json()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/scenes/main_menu.py b/scripts/scenes/main_menu.py
--- a/scripts/scenes/main_menu.py	(revision 3f7b4f7e43c009cb93e7a191f606ebb9f3b99838)
+++ b/scripts/scenes/main_menu.py	(date 1735312165757)
@@ -505,4 +505,4 @@
         current_index = difficulties.index(self.difficulty)
         next_index = (current_index + 1) % len(difficulties)
         self.difficulty = difficulties[next_index]
-        self.save_settings_to_json()
\ No newline at end of file
+        self.save_settings_to_json()
Index: test.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test.py b/test.py
new file mode 100644
--- /dev/null	(date 1735312130875)
+++ b/test.py	(date 1735312130875)
@@ -0,0 +1,32 @@
+import os
+
+def count_lines_in_file(file_path):
+    """Подсчитывает количество строк в файле."""
+    try:
+        with open(file_path, 'r', encoding='utf-8') as f:
+            return len(f.readlines())
+    except (UnicodeDecodeError, FileNotFoundError):
+        # Пропускаем файлы, которые не можем прочитать (например, бинарные файлы)
+        return 0
+
+def count_lines_in_directory(directory):
+    """Подсчитывает количество строк во всех файлах в указанной директории, исключая .venv."""
+    total_lines = 0
+
+    for root, dirs, files in os.walk(directory):
+        # Исключаем папку .venv
+        if '.venv' in dirs:
+            dirs.remove('.venv')
+
+        for file in files:
+            file_path = os.path.join(root, file)
+            # Учитываем только файлы с расширением .py (или другие, которые вам нужны)
+            if file.endswith('.py'):
+                total_lines += count_lines_in_file(file_path)
+
+    return total_lines
+
+# Путь к директории, например, текущая директория
+directory = '.'
+total_lines = count_lines_in_directory(directory)
+print(f"Общее количество строк в Python-файлах: {total_lines}")
